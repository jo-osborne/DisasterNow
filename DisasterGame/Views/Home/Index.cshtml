@{
    ViewBag.Title = "Home Page";
}
<div style="position: absolute; top: 790px; left: 1400px; z-index:9;">
    Time left: <span id="timeleft"></span>
    <br />
    People on bus: <span id="peopleOnBus">0</span><br />
    Name: <span id="playername"></span>
</div>

<div id="results" style="display: none; position: absolute; top: 800px; left: 1352px"></div>
<img src="/Images/bus.jpg" style="display: none" />
<div>
    <img src="Images/logo.png" class="logo" />

    <img src="Images/sidebar.jpg" style="position: absolute; top: 0; left: 1352px" />



    <canvas id="canvas1" height="900" width="1352" style="position: absolute; top: 80px; left: 0"></canvas>
</div>
<script>
    var busCapasity = 3;
    var dropOffX = 105;
    var dropOffY = 775;
    var moveShapeHub = $.connection.moveShapeHub,
    // Send a maximum of 10 messages per second
    // (mouse movements trigger a lot of messages)
    messageFrequency = 10,
    // Determine how often to send messages in
    // time to abide by the messageFrequency
    updateRate = 1000 / messageFrequency,
    shapeModel = {
        left: 0,
        top: 0,
        id: "",
        full: false
    },
    newModel = {
        left: 0,
        top: 0,
        id: "",
        full: false
    },
    moved = false;

    $.connection.hub.start().done(function () {
        console.log("Hub started");
        moveShapeHub.server.updateModel(newModel);

        $.ajax({
            url: "/getshapes",
            //data: data,
            success: function (data) {
                var serverShapes = data;
                var foundShape = false;
                var localShapes = canvasState.shapes;
                console.log("serverShapes=" + serverShapes);
                console.log("serverShapes.length=" + serverShapes.length);
                console.log("localShapes.length=" + localShapes.length);
                for (var i = 0; i < serverShapes.length; i++) {
                    for (var j = 0; j < localShapes.length; j++) {
                        if (localShapes[j].id == serverShapes[i].id) {
                            foundShape = true;
                            break;
                        }
                    }
                    console.log(serverShapes[i].id + " " + foundShape);
                    if (!foundShape) {
                        canvasState.addShape(new Shape(serverShapes[i].id, serverShapes[i].left, serverShapes[i].top, 40, 40, 'lightskyblue'));
                    }
                }
                canvasState.valid = false;
                canvasState.draw();
            },
        });

        $.ajax({
            url: "/getpeople",
            success: function (data) {
                var serverPeople = data;
                var foundShape = false;
                var localPeople = canvasState.people;
                console.log("serverPeople=" + serverPeople);
                console.log("serverPeople.length=" + serverPeople.length);
                console.log("localPeople.length=" + localPeople.length);
                for (var i = 0; i < serverPeople.length; i++) {
                    //for (var j = 0; j < localPeople.length; j++) {
                    //    if (localPeople[j].id == serverPeople[i].id) {
                    //        foundShape = true;
                    //        break;
                    //    }
                    //}
                    //console.log(serverPeople[i].id + " " + foundShape);
                    //if (!foundShape) {
                    canvasState.addPerson(new Person(serverPeople[i].id, serverPeople[i].left, serverPeople[i].top, 20, 20, serverPeople[i].visible));
                    //}
                }
                canvasState.valid = false;
                canvasState.draw();
            },
        });

        $shape.draggable({
            drag: function () {
                shapeModel = $shape.offset();
                moved = true;
            }
        });
        // Start the client side server update interval
        setInterval(updateServerModel, updateRate);
    });
    function updateServerModel() {
        // Only update server if we have a new movement
        if (moved) {
            moveShapeHub.server.updateModel(shapeModel);
            moved = false;
        }
    }

    // By Simon Sarris
    // www.simonsarris.com
    // sarris@acm.org
    //
    // Last update December 2011
    //
    // Free to use and distribute at will
    // So long as you are nice to people, etc

    // Constructor for Shape objects to hold data for all drawn objects.
    // For now they will just be defined as rectangles.
    function Shape(id, x, y, w, h, full) {
        // This is a very simple and unsafe constructor. All we're doing is checking if the values exist.
        // "x || 0" just means "if there is a value for x, use that. Otherwise use 0."
        // But we aren't checking anything else! We could put "Lalala" for the value of x 
        this.id = id;
        this.x = x || 0;
        this.y = y || 0;
        this.w = w || 1;
        this.h = h || 1;
        this.full = full;
    }

    // Draws this shape to a given context
    Shape.prototype.draw = function (ctx) {
        //ctx.fillStyle = this.fill;
        //ctx.fillRect(this.x, this.y, this.w, this.h);
        var img = new Image;
        //img.height = this.h;
        //img.width = this.w;
        if (this.full) {
            img.src = "Images/fullBus.png";
        }
        else {
            img.src = "Images/bus.png";
        }
        if (this.id != $('#playername').text()) {
            ctx.globalAlpha = 0.5;
        }
        ctx.drawImage(img, this.x, this.y, this.w, this.h);
        ctx.globalAlpha = 1;
    }

    // Determine if a point is inside the shape's bounds
    Shape.prototype.contains = function (mx, my) {
        // All we have to do is make sure the Mouse X,Y fall in the area between
        // the shape's X and (X + Width) and its Y and (Y + Height)
        return (this.x <= mx) && (this.x + this.w >= mx) &&
                (this.y <= my) && (this.y + this.h >= my);
    }

    function Person(id, x, y, w, h, visible) {
        // This is a very simple and unsafe constructor. All we're doing is checking if the values exist.
        // "x || 0" just means "if there is a value for x, use that. Otherwise use 0."
        // But we aren't checking anything else! We could put "Lalala" for the value of x 
        this.id = id;
        this.x = x || 0;
        this.y = y || 0;
        this.w = w || 1;
        this.h = h || 1;
        this.visible = visible;
    }

    // Draws this person to a given context
    Person.prototype.draw = function (ctx) {
        if (this.visible) {
            //console.log("Drawing a person " + this.id);
            //ctx.fillStyle = this.fill;
            //ctx.fillRect(this.x, this.y, this.w, this.h);
            var img = new Image;
            //img.height = this.h;
            //img.width = this.w;
            img.src = "Images/person.png";
            ctx.drawImage(img, this.x, this.y, this.w, this.h);
        }
    }

    // Determine if a point is inside the person's bounds
    Person.prototype.contains = function (mx, my) {
        // All we have to do is make sure the Mouse X,Y fall in the area between
        // the person's X and (X + Width) and its Y and (Y + Height)
        return (this.x <= mx) && (this.x + this.w >= mx) &&
                (this.y <= my) && (this.y + this.h >= my);
    }

    var moveShapeHub = $.connection.moveShapeHub,
        $shape = $("#shape"),
        // Send a maximum of 10 messages per second
        // (mouse movements trigger a lot of messages)
        messageFrequency = 10,
        // Determine how often to send messages in
        // time to abide by the messageFrequency
        updateRate = 1000 / messageFrequency,
        shapeModel = {
            left: 0,
            top: 0,
            id: "",
            full: false
        }

    function CanvasState(canvas) {


        // **** First some setup! ****

        this.canvas = canvas;
        this.width = canvas.width;
        this.height = canvas.height;
        this.ctx = canvas.getContext('2d');
        // This complicates things a little but but fixes mouse co-ordinate problems
        // when there's a border or padding. See getMouse for more detail
        var stylePaddingLeft, stylePaddingTop, styleBorderLeft, styleBorderTop;
        if (document.defaultView && document.defaultView.getComputedStyle) {
            this.stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingLeft'], 10) || 0;
            this.stylePaddingTop = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingTop'], 10) || 0;
            this.styleBorderLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderLeftWidth'], 10) || 0;
            this.styleBorderTop = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderTopWidth'], 10) || 0;
        }
        // Some pages have fixed-position bars (like the stumbleupon bar) at the top or left of the page
        // They will mess up mouse coordinates and this fixes that
        var html = document.body.parentNode;
        this.htmlTop = html.offsetTop;
        this.htmlLeft = html.offsetLeft;

        // **** Keep track of state! ****

        this.valid = false; // when set to false, the canvas will redraw everything
        this.shapes = [];  // the collection of things to be drawn
        this.people = [];  // the collection of things to be drawn
        this.dragging = false; // Keep track of when we are dragging
        // the current selected object. In the future we could turn this into an array for multiple selection
        this.selection = null;
        this.dragoffx = 0; // See mousedown and mousemove events for explanation
        this.dragoffy = 0;

        // **** Then events! ****

        // This is an example of a closure!
        // Right here "this" means the CanvasState. But we are making events on the Canvas itself,
        // and when the events are fired on the canvas the variable "this" is going to mean the canvas!
        // Since we still want to use this particular CanvasState in the events we have to save a reference to it.
        // This is our reference!
        var myState = this;

        //fixes a problem where double clicking causes text to get selected on the canvas
        canvas.addEventListener('selectstart', function (e) { e.preventDefault(); return false; }, false);
        // Up, down, and move are for dragging
        canvas.addEventListener('mousedown', function (e) {
            var mouse = myState.getMouse(e);
            var mx = mouse.x;
            var my = mouse.y;
            var shapes = myState.shapes;
            var l = shapes.length;
            for (var i = l - 1; i >= 0; i--) {
                if (shapes[i].contains(mx, my)) {
                    if (shapes[i].id == $('#playername').text()) {
                        var mySel = shapes[i];
                        // Keep track of where in the object we clicked
                        // so we can move it smoothly (see mousemove)
                        myState.dragoffx = mx - mySel.x;
                        myState.dragoffy = my - mySel.y;
                        myState.dragging = true;
                        myState.selection = mySel;
                        myState.valid = false;
                        return;
                    }
                }
            }
            // havent returned means we have failed to select anything.
            // If there was an object selected, we deselect it
            if (myState.selection) {
                myState.selection = null;
                myState.valid = false; // Need to clear the old selection border
            }
        }, true);
        canvas.addEventListener('mousemove', function (e) {
            if (myState.dragging) {
                var mouse = myState.getMouse(e);
                // We don't want to drag the object by its top-left corner, we want to drag it
                // from where we clicked. Thats why we saved the offset and use it here
                myState.selection.x = mouse.x - myState.dragoffx;
                myState.selection.y = mouse.y - myState.dragoffy;
                shapeModel.left = myState.selection.x;
                shapeModel.top = myState.selection.y;
                shapeModel.id = myState.selection.id;
                shapeModel.full = myState.selection.full;

                console.log(shapeModel.left + " " + shapeModel.top);
                if (shapeModel.left < dropOffX && shapeModel.top > dropOffY) {
                    $("#peopleOnBus").text(0);
                    shapeModel.full = false;
                    myState.selection.full = false;
                }

                var people = myState.people;
                for (var i = 0; i < people.length; i++) {
                    var person = people[i]
                    if (person.visible && person.contains(myState.selection.x, myState.selection.y)) {
                        var peopleOnBus = parseInt($("#peopleOnBus").text());
                        if (peopleOnBus < busCapasity) {
                            person.visible = false;
                            $("#peopleOnBus").text(peopleOnBus + 1);
                            if (peopleOnBus + 1 >= busCapasity) {
                                shapeModel.full = true;
                                myState.selection.full = true;
                            }
                            var personModel = {
                                left: person.x,
                                top: person.y,
                                id: person.id,
                                visible: person.visible
                            }
                            moveShapeHub.server.updatePerson(personModel);
                        }
                    }
                }
                moveShapeHub.server.updateModel(shapeModel);
                myState.valid = false; // Something's dragging so we must redraw                
            }
        }, true);
        moveShapeHub.client.updateShape = function (model) {
            shapeModel = model;
            // Gradually move the shape towards the new location (interpolate)
            // The updateRate is used as the duration because by the time
            // we get to the next location we want to be at the "last" location
            // We also clear the animation queue so that we start a new
            // animation and don't lag behind.
            //$shape.animate(shapeModel, { duration: updateRate, queue: false });  
            console.log("Received update for " + shapeModel.id);
            var foundShape = false;
            var shapes = myState.shapes;
            var l = shapes.length;
            console.log("l=" + l);
            for (var i = 0; i < l; i++) {
                console.log("Checking if this is the right shape: " + shapes[i].id);
                if (shapes[i].id == shapeModel.id) {
                    var mySel = shapes[i];
                    mySel.x = shapeModel.left;
                    mySel.y = shapeModel.top;
                    myState.valid = false;
                    foundShape = true;
                    break;
                }
            }
            if (!foundShape) {
                myState.addShape(new Shape(shapeModel.id, shapeModel.left, shapeModel.top, 40, 40, shapeModel.full));
            }
        };
        moveShapeHub.client.updatePerson = function (model) {
            //var foundShape = false;
            var people = myState.people;
            var l = people.length;
            for (var i = 0; i < l; i++) {
                if (people[i].id == model.id) {
                    var mySel = people[i];
                    //mySel.x = model.left;
                    //mySel.y = model.top;
                    mySel.visible = model.visible;
                    myState.valid = false;
                    //foundShape = true;
                    break;
                }
            }
            //if (!foundShape) {
            //    console.log("before " + myState.shapes.length);
            //    myState.addShape(new Shape(shapeModel.id, shapeModel.left, shapeModel.top, 40, 40, 'lightskyblue'));
            //    console.log("after" + myState.shapes.length);
            //}
        };
        moveShapeHub.client.updateTimer = function (model) {
            $("#timeleft").text(model.timeleft);
        };
        moveShapeHub.client.gameOver = function (model) {
            $("#results").show();
            $("#results").text("Saved: " + model.survivers + ", perished " + model.victims);
        };
        canvas.addEventListener('mouseup', function (e) {
            myState.dragging = false;
        }, true);
        // double click for making new shapes
        //canvas.addEventListener('dblclick', function (e) {
        //    var mouse = myState.getMouse(e);
        //    myState.addShape(new Shape(mouse.x - 10, mouse.y - 10, 20, 20, 'rgba(0,255,0,.6)'));
        //}, true);

        // **** Options! ****

        this.selectionColor = '#CC0000';
        this.selectionWidth = 2;
        this.interval = 30;
        setInterval(function () { myState.draw(); }, myState.interval);
    }

    CanvasState.prototype.addShape = function (shape) {
        this.shapes.push(shape);
        this.valid = false;
    }

    CanvasState.prototype.addPerson = function (person) {
        this.people.push(person);
        this.valid = false;
    }

    CanvasState.prototype.clear = function () {
        this.ctx.clearRect(0, 0, this.width, this.height);
    }

    // While draw is called as often as the INTERVAL variable demands,
    // It only ever does something if the canvas gets invalidated by our code
    CanvasState.prototype.draw = function () {
        // if our state is invalid, redraw and validate!
        if (!this.valid) {
            this.clear();
            var img = new Image;
            img.src = "Images/map.png";
            this.ctx.drawImage(img, 0, 0, 1352, 900);

            var ctx = this.ctx;
            var shapes = this.shapes;
            var people = this.people;


            // ** Add stuff you want drawn in the background all the time here **

            var myShape;
            // draw all shapes
            var l = shapes.length;
            for (var i = 0; i < l; i++) {
                var shape = shapes[i];
                // We can skip the drawing of elements that have moved off the screen:
                if (shape.x > this.width || shape.y > this.height ||
                    shape.x + shape.w < 0 || shape.y + shape.h < 0) continue;
                shapes[i].draw(ctx);
                if (shapes[i].id == $("#playername").text()) {
                    myShape = shapes[i];
                }
            }

            myShape.draw(ctx);

            // draw all people
            var pl = people.length;
            for (var i = 0; i < pl; i++) {
                var person = people[i];
                console.log(person);
                // We can skip the drawing of elements that have moved off the screen:
                if (person.x > this.width || person.y > this.height ||
                    person.x + person.w < 0 || person.y + person.h < 0) continue;
                person.draw(ctx);
            }

            // draw selection
            // right now this is just a stroke along the edge of the selected Shape
            if (this.selection != null) {
                ctx.strokeStyle = this.selectionColor;
                ctx.lineWidth = this.selectionWidth;
                var mySel = this.selection;
                ctx.strokeRect(mySel.x, mySel.y, mySel.w, mySel.h);
            }

            // ** Add stuff you want drawn on top all the time here **

            this.valid = true;
        }
    }


    // Creates an object with x and y defined, set to the mouse position relative to the state's canvas
    // If you wanna be super-correct this can be tricky, we have to worry about padding and borders
    CanvasState.prototype.getMouse = function (e) {
        var element = this.canvas, offsetX = 0, offsetY = 0, mx, my;

        // Compute the total offset
        if (element.offsetParent !== undefined) {
            do {
                offsetX += element.offsetLeft;
                offsetY += element.offsetTop;
            } while ((element = element.offsetParent));
        }

        // Add padding and border style widths to offset
        // Also add the <html> offsets in case there's a position:fixed bar
        offsetX += this.stylePaddingLeft + this.styleBorderLeft + this.htmlLeft;
        offsetY += this.stylePaddingTop + this.styleBorderTop + this.htmlTop;

        mx = e.pageX - offsetX;
        my = e.pageY - offsetY;

        // We return a simple javascript object (a hash) with x and y defined
        return { x: mx, y: my };
    }

    // If you dont want to use <body onLoad='init()'>
    // You could uncomment this init() reference and place the script reference inside the body tag
    //init();

    //var canvasState = new CanvasState(document.getElementById('canvas1'));

    function getPlayersName() {
        $('#playername').text(prompt('Enter your name:', ''));
    }

    function createPlayersShape() {
        console.log("Creating shape");
        canvasState = new CanvasState(document.getElementById('canvas1'));
        var newShape = new Shape($('#playername').text(), (Math.random() * 60) + 1, (Math.random() * 60) + 1, 40, 40, false);
        canvasState.addShape(newShape);
        newModel.left = newShape.x;
        newModel.top = newShape.y;
        newModel.id = newShape.id;

        console.log("Sending new shape to server " + newShape.id);
    }

    getPlayersName();
    createPlayersShape();

    // Now go make something amazing!
</script>

